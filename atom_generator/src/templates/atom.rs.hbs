//-----------------------------------------------------------------------------
// DO NOT EDIT THIS FILE!
// This is generated by wise_units-atom_generator.
//-----------------------------------------------------------------------------

use crate::{
    is_compatible_with::{DefaultCompatibility, IsCompatibleWith},
    parser::{
        definition::Definition, function_set::FunctionSet, Classification, Composable, Composition,
        Dimension, Property, UcumSymbol,
    },
    reducible::Reducible,
    UcumUnit, Unit,
};
use std::fmt;

#[derive(Clone, Copy, Debug, Eq, PartialOrd, Ord, Hash)]
pub enum Atom {
    {{~ #each atoms }}
    {{ type_name }},{{ /each }}
}

impl Atom {
    pub(crate) fn definition(self) -> Definition {
        let result = match self {
            {{~ #each atoms }}
            Self::{{ type_name }} => {{ definition_signature }},{{ /each }}
        };

        result.expect("BUG! Bad Atom -> Definition mapping!")
    }

    #[must_use]
    pub const fn property(self) -> Property {
        match self {
            {{ #each atoms }}
            Self::{{ type_name }} => Property::{{ camelCase property }},
            {{ /each }}
        }
    }
}

impl UcumSymbol for Atom {
    fn classification(&self) -> Classification {
        match *self {
            {{~ #each atoms }}
            Self::{{ type_name }} => Classification::{{ classification }},
            {{ /each }}
        }
    }

    fn names(&self) -> Vec<&'static str> {
        match *self {
            {{~ #each atoms }}
            Self::{{ type_name }} => vec![{{ #each names }}"{{ this }}",{{ /each}}],
            {{ /each }}
        }
    }

    fn primary_code(&self) -> &'static str {
        match *self {
            {{~ #each atoms }}
            Self::{{ type_name }} => "{{ primary_code }}",
            {{ /each }}
        }
    }

    fn print_symbol(&self) -> Option<&'static str> {
        match *self {
            {{~ #each atoms }}
            {{~ #if print_symbol }}
            Self::{{ type_name }} => Some("{{ print_symbol }}"),
            {{~ /if}}{{ /each }}
            _ => None,
        }
    }

    fn secondary_code(&self) -> Option<&'static str> {
        match *self {
            {{~ #each atoms }}
            {{~ #if secondary_code }}
            Self::{{ type_name }} => Some("{{ secondary_code }}"),
            {{~ /if ~}}{{ /each }}
            _ => None,
        }
    }

    fn definition_value(&self) -> f64 {
        self.definition().value()
    }

    fn definition_unit(&self) -> Unit {
        Unit::new(self.definition().terms().clone())
    }
}

impl UcumUnit for Atom {
    fn scalar(&self) -> f64 {
        self.reduce_value(1.0)
    }

    fn magnitude(&self) -> f64 {
        self.calculate_magnitude(self.scalar())
    }

    fn is_arbitrary(&self) -> bool {
        match *self {
            {{~ #each atoms }}
            {{~ #if is_arbitrary }}
            Self::{{ type_name }} => true,
            {{~ /if}}{{ /each }}
            _ => false,
        }
    }

    fn is_special(&self) -> bool {
        match *self {
            {{~ #each atoms }}
            {{~ #if is_special }}
            Self::{{ type_name }} => true,
            {{~ /if}}{{ /each }}
            _ => false,
        }
    }

    fn is_metric(&self) -> bool {
        match *self {
            {{~ #each atoms }}
            {{~ #if is_metric }}
            Self::{{ type_name }} => true,
            {{~ /if}}{{ /each }}
            _ => false,
        }
    }
}

impl Reducible for Atom {
    fn reduce_value(&self, value: f64) -> f64 {
        self.definition().reduce_value(value)
    }

    fn calculate_magnitude(&self, value: f64) -> f64 {
        if self.is_special() {
            self.definition().calculate_magnitude(value)
        } else {
            1.0
        }
    }
}

impl DefaultCompatibility for Atom {}

impl Composable for Atom {
    fn composition(&self) -> Composition {
        match self {
            Self::Candela => Composition::new(Dimension::LuminousIntensity, 1),
            Self::Coulomb => Composition::new(Dimension::ElectricCharge, 1),
            Self::Gram => Composition::new(Dimension::Mass, 1),
            Self::Kelvin => Composition::new(Dimension::Temperature, 1),
            Self::Meter => Composition::new(Dimension::Length, 1),
            Self::Radian => Composition::new(Dimension::PlaneAngle, 1),
            Self::Second => Composition::new(Dimension::Time, 1),
            _ => self.definition().terms().composition(),
        }
    }
}

impl PartialEq for Atom {
    fn eq(&self, other: &Self) -> bool {
        if !self.is_compatible_with(other) {
            return false;
        }

        self.scalar() == other.scalar()
    }
}

impl fmt::Display for Atom {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.primary_code())
    }
}
