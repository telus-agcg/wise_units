//! This module is responsible for generating the Rust code that built into the
//! main `wise_units` crate. Each part of it expects some data that was
//! extracted from the UCUM TOML file (and any custom units defined by 3rd
//! party libraries) and then generates all code that defines the
//! parsing, interpreting, and types of atoms (units) that can be used by a
//! consuming library or application.
//!

mod atom;
mod classification;
mod handlebars;
mod property;
mod symbol_grammar;

use proc_macro2::TokenStream;

use self::handlebars::HANDLEBARS;

use crate::rust_structs::RustAtomList;
use std::{
    fs::File,
    io::{self, Write},
    path::{Path, PathBuf},
    process::Command,
};

const BANNER: &str =
    "//-----------------------------------------------------------------------------
// DO NOT EDIT THIS FILE!
// This is generated by wise_units-atom_generator.
//-----------------------------------------------------------------------------

";

/// Main function for generating all files that need to be generated from a
/// `RustAtomList`.
///
pub(crate) fn generate_files(rust_atom_list: &RustAtomList) {
    generate_classification_file(rust_atom_list);
    generate_property_file(rust_atom_list);
    generate_atom_file(rust_atom_list);
}

fn generate_classification_file(rust_atom_list: &RustAtomList) {
    let file_body = self::classification::generate_file_body(rust_atom_list);
    let file_path = build_file_path("parser/classification.rs");
    write_project_file(&file_path, &file_body, true);
}

fn generate_property_file(rust_atom_list: &RustAtomList) {
    let file_body = self::property::generate_file_body(rust_atom_list);
    let file_path = build_file_path("parser/property.rs");
    write_project_file(&file_path, &file_body, true);
}

fn generate_atom_file(rust_atom_list: &RustAtomList) {
    let file_body = self::atom::generate_file_body(rust_atom_list);
    let file_path = build_file_path("atom.rs");
    write_project_file(&file_path, &file_body, true);
}

fn build_file_path(file_name: &str) -> PathBuf {
    let dest_dir = "../api/src/";

    Path::new(&dest_dir).join(file_name)
}

fn write_project_file(file_path: &Path, file_body: &str, do_format: bool) {
    let mut f = File::create(file_path).unwrap();

    f.write_all(file_body.as_bytes())
        .expect("Problem writing the file");

    if do_format {
        // Now call `rustfmt` on it.
        let output = Command::new("rustfmt")
            .arg(file_path)
            .output()
            .unwrap_or_else(|_| panic!("`rustfmt` failed on file {}", file_path.display()));

        io::stderr().write_all(&output.stderr).unwrap();
    }
}

fn pretty_format(token_stream: &TokenStream) -> String {
    let token_string = token_stream.to_string();

    // Run the output through `prettyplease`. This should catch some syntactical mess-ups.
    //
    let syn_file = syn::parse_file(&token_string).unwrap();
    let mut code = prettyplease::unparse(&syn_file);

    // Insert the "don't edit me" banner.
    code.insert_str(0, BANNER);

    code
}
